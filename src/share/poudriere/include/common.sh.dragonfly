#!/bin/sh
# DRAGONFLY SPECIFIC DEFINITIONS

NULLMOUNT="/sbin/mount_null"
NULLFSREF="null"
NO_ZFS=TRUE
USE_TMPFS=true
JAILED=0
TMPFS_WRKDIR=0
TMPFS_DATA=0
TMPFS_ALL=0
TMPFS_LOCALBASE=0

injail()  {
	chroot ${MASTERMNT}${MY_JOBID+/../${MY_JOBID}} $@
}

jstart () {
	# NO OP on DragonFly
}

jkill() {
	# NO OP on DragonFly
}

jstop () {
	# NO OP on DragonFly
}

jail_runs() {
	[ $# -ne 1 ] && eargs jail_runs jname
	local mounted=$(check_mount ${1})
	[ -n "${mounted}" ] && return 0
	return 1
}

jail_start() {
	[ $# -lt 2 ] && eargs jail_start name ptname setname
	local name=$1
	local ptname=$2
	local setname=$3
	local portsdir
	local arch host_arch
	local mnt
	local needfs="${NULLFSREF}"

	_pget portsdir ${ptname} mnt
	_jget arch ${name} arch
	get_host_arch host_arch
	_jget mnt ${name} mnt

	JAIL_OSVERSION=$(awk '/\#define __DragonFly_version/ { print $3 }' "${mnt}/usr/include/sys/param.h")

	[ -d ${DISTFILES_CACHE:-/nonexistent} ] || err 1 "DISTFILES_CACHE directory does not exist. (c.f. poudriere.conf)"

	jail_exists ${name} || err 1 "No such jail: ${name}"
	jail_runs ${name} && err 1 "jail already running: ${name}"
	if [ -z "${NOLINUX}" ]; then
		if [ "${arch}" = "i386" ]; then
			needfs="${needfs} linprocfs"
			sysctl -n compat.linux.osrelease >/dev/null 2>&1 || kldload linux
		fi
	fi
	[ -n "${USE_TMPFS}" ] && needfs="${needfs} tmpfs"
	[ "${USE_PROCFS}" = "yes" ] && needfs="${needfs} procfs"
	for fs in ${needfs}; do
		if ! lsvfs $fs >/dev/null 2>&1; then
			if [ $JAILED -eq 0 ]; then
				kldload $fs || err 1 "Required kernel module '${fs}' not found"
			else
				err 1 "please load the $fs module on host using \"kldload $fs\""
			fi
		fi
	done

	mkdir -p ${MASTERMNT}
	# Don't limit MASTERMNT.
	# The testport builds there, so it needs to be unlimited
	# Additionally, the dependency check for bulk all needs a lot of space
	mount_tmpfs tmpfs ${MASTERMNT}

	export HOME=/root
	export USER=root
	export TERM=cons25
	[ -z "${NO_FORCE_PACKAGE}" ] && export FORCE_PACKAGE=yes
	[ -z "${NO_PACKAGE_BUILDING}" ] && export PACKAGE_BUILDING=yes
	[ ${SET_STATUS_ON_START-1} -eq 1 ] && export STATUS=1
	msg_n "Creating the reference jail..."

	cpdup -x -VV -i0 ${mnt}/ ${MASTERMNT}/
	mkdir -p 	${MASTERMNT}/compat/linprocfs \
			${MASTERMNT}/compat/linux/proc \
			${MASTERMNT}/compat/svr4 \
			${MASTERMNT}/distfiles \
			${MASTERMNT}/new_packages/All \
			${MASTERMNT}/new_packages/Latest \
			${MASTERMNT}/options \
			${MASTERMNT}/packages \
			${MASTERMNT}/portdistfiles \
			${MASTERMNT}/poudriere \
			${MASTERMNT}/usr/local \
			${MASTERMNT}/.npkg

	if [ -d "${CCACHE_DIR:-/nonexistent}" ]; then
		mkdir ${MASTERMNT}/root/.ccache
		cat >> "${MASTERMNT}/etc/make.conf" <<-EOF
		WITH_CCACHE_BUILD=yes
		CCACHE_DIR=/root/.ccache
		EOF
	fi

	cat >> "${MASTERMNT}/etc/make.conf" <<-EOF
	USE_PACKAGE_DEPENDS=yes
	BATCH=yes
	WRKDIRPREFIX=/wrkdirs
	PORT_DBDIR=/options
	PORTSDIR=/usr/ports
	PACKAGES=/packages
	DISTDIR=/distfiles
	EOF

	setup_makeconf ${MASTERMNT}/etc/make.conf ${name} ${ptname} ${setname}
	load_blacklist ${mnt} ${ptname} ${setname}

	test -n "${RESOLV_CONF}" && cp -v "${RESOLV_CONF}" "${MASTERMNT}/etc/"

	msg "Mounting system devices for ${MASTERNAME}"
	do_jail_mounts "${MASTERMNT}" ${arch}

	PACKAGES=${POUDRIERE_DATA}/packages/${MASTERNAME}

	[ -d "${portsdir}/ports" ] && portsdir=${portsdir}/ports
	msg "Mounting ports/packages/distfiles"

	was_a_bulk_run && stash_packages

	do_portbuild_mounts ${MASTERMNT} ${name} ${ptname} ${setname}
	cp -a ${MASTERMNT}/etc ${MASTERMNT}/etc2
	cp -a ${MASTERMNT}/var ${MASTERMNT}/var2

	# set up /usr/local for testport
	JAILMNT=${mnt} injail /usr/sbin/mtree -q -U -f \
	   /usr/ports/Templates/BSD.local.dist -d -e -p /usr/local >/dev/null

	# The master jail is malleable so /etc/ can be modified later
	# The slave jails are read only.  All have same source

		PKGNG=1
		PKG_EXT="txz"
		PKG_BIN="/.p/pkg-static"
		PKG_ADD="${PKG_BIN} add"
		PKG_DELETE="${PKG_BIN} delete -y -f"
		PKG_VERSION="${PKG_BIN} version"

		[ -n "${PKG_REPO_SIGNING_KEY}" ] &&
			! [ -f "${PKG_REPO_SIGNING_KEY}" ] &&
			err 1 "PKG_REPO_SIGNING_KEY defined but the file is missing."

	return 0

}

jail_stop() {
	[ $# -ne 0 ] && eargs jail_stop
	local mnt rem
	local AWKCMD1='{ if ($3 ~ mnt && $3 !~ /\/ref/) { print $3 }}'
	local AWKCMD2='{ if ($3 ~ mnt) { print $3 }}'

	cd /
	msg "Umounting file systems"
	mnt=${MASTERMNT%/ref}
	mount | awk -v mnt="${mnt}" "${AWKCMD1}" |  sort -r | xargs umount || :

	# We don't want to continue umounting /ref if had any failures so
	# far.  Let's check for mounts, and try 3 more times with 30 second
	# intervals

	for verify in A B C; do
		rem=$(mount | awk -v mnt="${mnt}" "${AWKCMD1}" | sort -r)
		if [ -z "${rem}" ]; then
		    break
		else
		    msg "Umounting not entirely successful.  Trying again in 30 seconds."
		    sleep 30
		    umount ${rem} || :
		fi
	done

	mount | awk -v mnt="${mnt}" "${AWKCMD2}" |  sort -r | xargs umount || :

	export STATUS=0

	# Don't override if there is a failure to grab the last status.
	_bget last_status status 2>/dev/null || :
	[ -n "${last_status}" ] && bset status "stopped:${last_status}" \
	    2>/dev/null || :
}

do_jail_mounts() {
	[ $# -ne 2 ] && eargs do_jail_mounts mnt arch
	local mnt="$1"
	local arch="$2"

	mount -t devfs devfs ${mnt}/dev
	[ "${USE_PROCFS}" = "yes" ] && mount -t procfs proc ${mnt}/proc
	if [ -z "${NOLINUX}" ]; then
		if [ "${arch}" = "i386" ]; then
			mount -t linprocfs linprocfs ${mnt}/compat/linux/proc
		fi
	fi

	return 0
}

start_builders() {
	local task mnt

	bset builders "${JOBS}"
	bset status "starting_builders:"
	for task in ${JOBS}; do
		local mnt="${MASTERMNT%/ref}/${task}"
		mkdir -p ${mnt}
		touch ${mnt}/virgin
	done
	bset epoch "$(date '+%s')"
}

stop_builders() {
	local mnt

	# wait for the last running processes
	cat ${MASTERMNT}/.p/var/run/*.pid 2>/dev/null | xargs pwait 2>/dev/null

	msg "Stopping ${PARALLEL_JOBS} builders"

	# wait for slaves to finish dismounting
	sleep 3

	cd /
	mnt=${MASTERMNT%/ref}
	mount | awk -v mnt="${mnt}" '{ if ($3 ~ mnt && $3 !~ /\/ref/) { print $3 }}' |  sort -r | xargs umount || :

	# No builders running, unset JOBS
	JOBS=""
}

dismount() {
	[ $# -ne 1 ] && eargs mountpoint
	umount ${1} 2>/dev/null || :
}

create_slave() {
	[ $# -ne 1 ] && eargs job-number
	local task="${1}"
	local mnt=${MASTERMNT%/ref}/${task}
	local arch=$(jget ${jname} arch)

	if [ -f ${mnt}/virgin ]; then
	    job_msg "Jail     ${COLOR_WHITE}Mounting"
	    # Make one-time readonly duplicate of base image, virgin hidden
	    ${NULLMOUNT} -o rdonly ${MASTERMNT} ${mnt}
	    do_jail_mounts ${mnt} ${arch}
	    do_portbuild_mounts ${mnt} ${jname} ${ptname} ${setname}
	else
	    job_msg "Jail     ${COLOR_WHITE}Renovating"
	fi
	# Refresh /usr/local and /etc and /var
	mount_tmpfs -s 200M  tmpfs ${mnt}/tmp
	mount_tmpfs -s 12G   tmfps ${mnt}/wrkdirs
	mount_tmpfs -s 12M   tmpfs ${mnt}/etc
	mount_tmpfs -s 200M  tmpfs ${mnt}/var
	mount_tmpfs -s 12G   tmpfs ${mnt}/usr/local
	mount_tmpfs -s 40M   tmpfs ${mnt}/.p
#	if [ "${LESS_SANDBOXING}" = "no" ]; then
		mount_tmpfs -s 2G    tmpfs ${mnt}/portdistfiles
		mount_tmpfs -s 1500M tmpfs ${mnt}/.npkg
#	fi
	cp -a ${mnt}/etc2/* ${mnt}/etc/
	cp -a ${mnt}/var2/* ${mnt}/var/

	JAILMNT=${mnt} injail /usr/sbin/mtree -q -U -f \
	   /usr/ports/Templates/BSD.local.dist -d -e -p /usr/local >/dev/null
}

destroy_slave() {
	[ $# -ne 1 ] && eargs job-number
	local stragglers
	local task="${1}"
	local mnt="${MASTERMNT%/ref}/${task}"
	local AWKCMD='{ if ($3 ~ mnt) { \
		len = length(mnt); \
		rest = substr($3, len+1); \
		if (       rest == "/etc" \
			|| rest == "/new_packages" \
			|| rest == "/portdistfiles" \
			|| rest == "/poudriere" \
			|| rest == "/tmp" \
			|| rest == "/usr/local" \
			|| rest == "/var" \
			|| rest == "/wrkdirs" \
		) print $3;
	}}'

	# make sure cwd is not on mount
	cd /

	mount | awk -v mnt="${mnt}" "${AWKCMD}" | sort -r | xargs umount || :
	# Possibly repeat dismount attempts in case some failed
	# This also helps reap mounts on previous failed attempts
	stragglers=$(mount | awk -v mnt="${mnt}" "${AWKCMD}" | sort -r)
	if [ -n "${stagglers}" ]; then
	   sleep 3
	   umount ${stagglers}
	fi
}

killtree() {
	local _pid=${1}
	local _sig=${2}
	local _child
	local _children

	# stop parent from attempting to folk
	if kill -17 ${_pid} 2>/dev/null; then
	   _children=$(pgrep -P ${_pid})
	   for _child in ${children}; do
	      killtree ${_child} ${_sig}
	   done
	   kill -${_sig} ${_pid}
	   pwait ${_pid} 2>/dev/null || :
	fi
}

check_mount() {
	[ $# -ne 1 ] && eargs jailname
	local mnt
	_jget mnt ${1} mnt
	local AWKCMD='{ if ($1 == mnt) print $3 }'
	mount | awk -v mnt="${mnt}" "${AWKCMD}"
	return 0
}

stop_build() {
	local pkgname="$1"
	local origin="$2"
	local build_failed="$3"
	local mnt

	_my_path mnt
	umount -f ${mnt}/.npkg 2>/dev/null || :
	rm -rf "${PACKAGES}/.npkg/${PKGNAME}"

	buildlog_stop "${pkgname}" ${origin} ${build_failed}
	log_stop
}
